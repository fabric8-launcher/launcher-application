package io.fabric8.launcher.creator.core.catalog

import io.fabric8.launcher.creator.core.*
import io.fabric8.launcher.creator.core.data.yamlIo
import io.fabric8.launcher.creator.core.maven.maven
import io.fabric8.launcher.creator.core.nodejs.mergePackageJson as mergePackage
import io.fabric8.launcher.creator.core.resource.Resources
import io.fabric8.launcher.creator.core.template.Transformer
import io.fabric8.launcher.creator.core.template.transformFiles
import java.nio.file.*
import java.nio.file.attribute.PosixFilePermission

val PATH_FILES: Path = Paths.get("files")
val PATH_POM: Path = Paths.get("pom.xml")
val PATH_MERGE_POM: Path = Paths.get("merge/pom.xml")
val PATH_PACKAGE: Path = Paths.get("package.json")
val PATH_MERGE_PACKAGE: Path = Paths.get("merge/package.json")
val PATH_NONE: Path = Paths.get("")

interface CatalogItem {
    fun apply(resources: Resources, props: Properties, extra: Properties): Resources
}

class CatalogItemContext(val targetDir: Path)

abstract class BaseCatalogItem(private val ctx: CatalogItemContext) : CatalogItem {
    protected val sourceDir: Path
        get() = Paths.get(this.javaClass.`package`.name.replace('.', '/')
                + "/" + this.javaClass.simpleName.toLowerCase())

    protected val targetDir: Path
        get() = ctx.targetDir

    protected fun <T : Generator> generator(genconst: (CatalogItemContext) -> T): T {
        return genconst(ctx)
    }

    protected fun name(vararg parts: Any?): String {
        return parts.filterNotNull().joinToString("-")
    }

    protected fun copy(from: Path = PATH_FILES, to: Path? = null) {
        val from2 = resolveClassPath(sourceDir.resolve(from))
        val to2 = if (to != null) targetDir.resolve(to) else targetDir
        copyFiles(from2, to2)
    }

    protected fun filesCopied(from: Path = PATH_FILES, to: Path? = null): Boolean {
        val from2 = resolveClassPath(sourceDir.resolve(from))
        val to2 = if (to != null) targetDir.resolve(to) else targetDir
        return Files.walk(from2).use {
            it.allMatch {
                val rel = from2.relativize(it)
                val target = to2.resolve(rel.toString())
                Files.exists(target)
            }
        }
    }

    protected fun move(original: Path, to: Path) {
        val original2 = targetDir.resolve(original)
        val to2 = targetDir.resolve(to)
        Files.move(original2, to2, StandardCopyOption.REPLACE_EXISTING)
    }

    protected fun transform(pattern: String, transformer: Transformer, dir: Path = PATH_NONE) {
        transformFiles(resolveClassPath(targetDir.resolve(dir)), pattern, transformer)
    }

    protected fun transform(patterns: List<String>, transformer: Transformer, dir: Path = PATH_NONE) {
        transformFiles(resolveClassPath(targetDir.resolve(dir)), patterns, transformer)
    }

    protected fun appendFile(targetFile: Path, sourceFile: Path) {
        val txt = streamFromPath(sourceDir.resolve(sourceFile)).use {
            it.bufferedReader().readText()
        }
        targetDir.resolve(targetFile).toFile().appendText(txt)
    }

    protected fun updatePom(appName: String, groupId: String, artifactId: String, version: String, pomFile: Path = PATH_POM) {
        maven.updateMetadata(targetDir.resolve(pomFile), appName, "Generated Application '$appName'")
        maven.updateGAV(targetDir.resolve(pomFile), groupId, artifactId, version)
    }

    protected fun mergePoms(sourcePom: Path = PATH_MERGE_POM, targetPom: Path = PATH_POM) {
        maven.mergePoms(targetDir.resolve(targetPom), sourceDir.resolve(sourcePom))
    }

    protected fun mergeVersionPoms(runtime: Runtime, targetPom: Path = PATH_POM) {
        val sourcePom = Paths.get("merge/pom.${validRuntime(runtime).version}.xml")
        if (existsFromPath(sourceDir.resolve(sourcePom))) {
            mergePoms(sourcePom, targetPom)
        }
    }

    protected fun updateMetadata(name: String, description: String = "A new application generated by the Red Hat Application Creator", pomFile: Path = PATH_POM) {
        maven.updateMetadata(targetDir.resolve(pomFile), name, description)
    }

    protected fun mergePackageJson(source: Path = PATH_MERGE_PACKAGE, target: Path = PATH_PACKAGE) {
        mergePackage(targetDir.resolve(target), sourceDir.resolve(source))
    }
}

private fun copyFiles(from: Path, to: Path) {
    Files.walk(from).use {
        it.forEach {
            if (!Files.isDirectory(it)) {
                val rel = from.relativize(it)
                val target = to.resolve(rel.toString())
                Files.createDirectories(target.parent)
                Files.copy(it, target, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.COPY_ATTRIBUTES)

                // This is (unfortunately) necessary because when the source of the files is a JAR on
                // the class path we lose all the file permission attributes. So we read them from a
                // file with file name / attributes pairs and restore the required permissions
                // TODO see if we can somehow automate this as part of the build process for example
                val attr = fileAttrs.get(it)
                if (attr != null) {
                    val perms = Files.getPosixFilePermissions(target)
                    if (attr.executable == true) {
                        perms += setOf(
                            PosixFilePermission.OWNER_EXECUTE,
                            PosixFilePermission.GROUP_EXECUTE,
                            PosixFilePermission.OTHERS_EXECUTE
                        )
                    }
                    Files.setPosixFilePermissions(target, perms)
                }
            }
        }
    }
}

interface Attrs : BaseProperties {
    val executable: Boolean?

    companion object {
        @JvmOverloads fun build(_map: Properties = propsOf(), block: Data.() -> Unit = {}) =
            BaseProperties.build(::Data, _map, block)
    }

    open class Data(map: Properties = propsOf()) : BaseProperties.Data(map), Attrs {
        override var executable: Boolean? by _map
    }
}

private val fileAttrs: Map<Path, Attrs> by lazy {
    val f = yamlIo.arrayFromStream(streamFromPath(Paths.get("META-INF/fileattr.yaml")))
    f.map { resolveClassPath(Paths.get("META-INF", it.get("file") as String)) to Attrs.build(it.get("attr") as Properties) }.toMap()
}
